## -------------------------------------------------------------------------------------------------
## -- Project : MLPro - The integrative middleware framework for standardized machine learning
## -- Package : mlpro.bf.streams.streams.clusters
## -- Module  : cluster.py
## -------------------------------------------------------------------------------------------------
## -- History :
## -- yyyy-mm-dd  Ver.      Auth.    Description
## -- 2025-09-19  1.0.0     DA       Creation 
## -------------------------------------------------------------------------------------------------

"""
Ver. 1.0.0 (2025-09-19)

This module provides an elementary stream generator shaping a single cluster of random points with any

- number of dimensions,
- number of instances,
- start and end center,
- start and end radii,
- random seed,
- data type (float32, float64)

"""

from typing import Union, Literal, List
import numpy as np

from mlpro.bf import Log, Mode
from mlpro.bf.exceptions import ParamError
from mlpro.bf.math import Element, MSpace, ESpace
from mlpro.bf.streams import Feature, Instance, Stream



# Export list for public API
__all__ = [ 'StreamCluster' ]



## -------------------------------------------------------------------------------------------------
## -------------------------------------------------------------------------------------------------
class StreamCluster(Stream):
    """
    This is a template class for native MLPro streams. It provides the basic functionality for all
    native MLPro streams.

    Parameters
    ----------
    p_num_dim : int
        Number of dimensions of the cluster.
    p_num_instances : int
        Total number of instances to be generated by the stream.
    p_boundaries : list, default=[-1000,1000]
        Boundaries for the random generation of cluster centers and radii.
    p_center_start : 'rnd' or list of float, default='rnd'
        Starting center of the cluster. If 'rnd', a random center within the boundaries will be
        generated.
    p_center_end : None, 'rnd' or list of float, default=None
        Optional end center of the cluster. If 'rnd', a random center within the boundaries will be
        generated. If provided, the cluster will move linearly from the start center to the end
        center over the total number of instances. If None, the cluster will remain static.
    p_radii_start : 'rnd' or list of float, default='rnd'
        Starting radii of the cluster. If 'rnd', random radii will be generated within 10% of the
        boundary range.
    p_radii_end : None, 'rnd' or list of float, default=None
        Optional end radii of the cluster. If 'rnd', random radii will be generated within 10% of the
        boundary range. If provided, the radii will change linearly from the start radii to the end
        radii over the total number of instances. If None, the radii will remain static.
    p_seed : int, default=1
        Random seed for reproducibility.
    p_dtype : type, default=np.float32
        Data type for the cluster parameters.
    p_logging : int, default=Log.C_LOG_NOTHING
        Logging level.

    Attributes
    ----------
    center : np.array
        Current center of the cluster.
    radii : np.array
        Current radii of the cluster.
    velocities : np.array
        Current velocities of the cluster.
    """

    C_NAME              = 'Cluster'
    C_RADII_RND_FACTOR  = 0.2          # Factor for random radii generation within boundary range

## -------------------------------------------------------------------------------------------------
    def __init__( self,
                  p_num_dim : int,
                  p_num_instances : int,
                  p_boundaries : list = [-1000,1000],
                  p_center_start : Union[Literal['rnd'], List[float]] = 'rnd',
                  p_center_end : Union[None, Literal['rnd'], List[float]] = None,
                  p_radii_start : Union[Literal['rnd'], List[float]] = 'rnd',
                  p_radii_end : Union[None, Literal['rnd'], List[float]] = None,
                  p_seed : int = 1,
                  p_dtype : type = np.float32,
                  p_logging : int = Log.C_LOG_NOTHING ):
        
        # 0 Parameter checks
        if p_num_dim < 1:
            raise ParamError('p_num_dim must be greater than 0!')       
        
        if p_num_instances < 1:
            raise ParamError('p_num_instances must be greater than 0!')
        
        if not isinstance(p_boundaries, list) or len(p_boundaries) != 2 or p_boundaries[0] >= p_boundaries[1]:
            raise ParamError('p_boundaries must be a list of two elements [min, max] with min < max!')

        if p_center_start not in ['rnd'] and not isinstance(p_center_start, list):
            raise ParamError('p_center_start must be either "rnd" or a list of floats!')

        if p_center_end not in [None, 'rnd'] and not isinstance(p_center_end, list):
            raise ParamError('p_center_end must be either None, "rnd" or a list of floats!')

        if p_radii_start not in ['rnd'] and not isinstance(p_radii_start, list):
            raise ParamError('p_radii_start must be either "rnd" or a list of floats!')

        if p_radii_end not in [None, 'rnd'] and not isinstance(p_radii_end, list):
            raise ParamError('p_radii_end must be either None, "rnd" or a list of floats!') 
        
        if p_dtype not in [np.float32, np.float64]:
            raise ParamError('p_dtype must be either np.float32 or np.float64!')    
        
        if ( p_center_end is None and p_radii_end is not None ) or ( p_center_end is not None and p_radii_end is None ):
            raise ParamError('p_center_end and p_radii_end must be both provided or both None!')
        
        if p_center_end is not None and p_num_instances == 1:
            raise ParamError('p_num_instances must be greater than 1 if p_center_end is supplied!')
        
        
        # 1 Init all attributes

        # 1.1 Numerics
        self._dtype : type      = p_dtype
        self.set_random_seed(p_seed)

        # 1.2 Cluster generation
        self._num_dim : int     = p_num_dim
        self._boundaries : list = p_boundaries

        # 1.3 Cluster attributes
        self._center_start = p_center_start
        self._center_end   = p_center_end
        self._radii_start  = p_radii_start
        self._radii_end    = p_radii_end
        self.size : int    = 0


        # 2 Call parent initializations
        super().__init__( #p_id = 0,
                          #p_name = p_name,
                          p_num_instances = p_num_instances,
                          #p_version = p_version,
                          p_feature_space = self._setup_feature_space(),
                          #p_label_space = p_label_space,
                          #p_sampler = p_sampler,
                          p_mode = Mode.C_MODE_SIM,
                          p_logging = p_logging )


## -------------------------------------------------------------------------------------------------
    def set_random_seed(self, p_seed=None):
        super().set_random_seed(p_seed)
        self._rgen = np.random.default_rng(seed=p_seed)


## -------------------------------------------------------------------------------------------------
    def _setup_feature_space(self) -> MSpace:
        feature_space : MSpace = ESpace()

        for i in range(self._num_dim):
            feature_space.add_dim( Feature( p_name_short = 'f_' + str(i),
                                            p_base_set = Feature.C_BASE_SET_R,
                                            p_name_long = 'Feature #' + str(i),
                                            p_name_latex = '',
                                            p_description = '',
                                            p_symmetrical = False,
                                            p_logging=Log.C_LOG_NOTHING ) )
        return feature_space    
    

## -------------------------------------------------------------------------------------------------
    def _reset(self):

       # 1.1 Center, start
        if self._center_start == 'rnd':
            self.center = self._rgen.uniform(self._boundaries[0], self._boundaries[1], size=self._num_dim).astype(self._dtype)
        else:
            self.center = np.array(self._center_start, dtype=self._dtype)


        # 1.2 Center, end and velocities
        if self._center_end != None:

            if self._center_end != 'rnd':
                self._center_end = np.array(self._center_end, dtype=self._dtype)
            else:
                self._center_end = self._rgen.uniform( self._boundaries[0], 
                                                       self._boundaries[1], 
                                                       size=self._num_dim ).astype(self._dtype)

            self.velocities = (self._center_end - self.center) / ( self._num_instances - 1 )

        else:
            self.velocities  = np.zeros(self._num_dim, dtype=self._dtype)


        # 1.3 Radii, start
        if self._radii_start == 'rnd':

            self.radii = self._rgen.uniform( 0, 
                                             (self._boundaries[1] - self._boundaries[0]) * self.C_RADII_RND_FACTOR, 
                                             size = self._num_dim ).astype(self._dtype) 

        else:
            self.radii = np.array(self._radii_start, dtype=self._dtype)


        # 1.4 Radii, end and rate of change of radii
        if self._radii_end != None:

            if self._center_end is None:
                raise ParamError('p_center_end must be provided if p_radii_end is provided!')

            if self._radii_end != 'rnd':

                if len(self._radii_end) != self._num_dim:
                    raise ParamError('Length of p_radii_end must be equal to p_num_dim!')

                self._radii_end = np.array(self._radii_end, dtype=self._dtype)

            else:
                self._radii_end = self._rgen.uniform( 0, 
                                                      (self._boundaries[1] - self._boundaries[0]) * self.C_RADII_RND_FACTOR, 
                                                      size=self._num_dim ).astype(self._dtype)

            self._roc_of_radii = (self._radii_end - self.radii) / self._num_instances

        else:
            self._roc_of_radii = np.zeros(self._num_dim, dtype=self._dtype)

    

## -------------------------------------------------------------------------------------------------
    def _get_next(self) -> Instance:

        # 1 Prepare a new instance
        feature_data = Element( p_set = self.get_feature_space() )
        new_inst     = Instance( p_feature_data = feature_data, p_tstamp = self.tstamp )
        

        # 2 Generate a random point within the cluster
        v  = np.random.normal(size=self._num_dim)
        v /= np.linalg.norm(v)
        r  = np.random.rand() ** (1.0 / self._num_dim)

        feature_data.set_values( self.center + v * r * self.radii )


        # 3 Update cluster parameters
        np.add( self.center, self.velocities, out=self.center )
        np.add( self.radii, self._roc_of_radii, out=self.radii )
        self.size += 1


        # 4 Return new instance
        return new_inst