## -------------------------------------------------------------------------------------------------
## -- Project : MLPro - The integrative middleware framework for standardized machine learning
## -- Package : mlpro.bf.streams.streams.clusters
## -- Module  : cluster.py
## -------------------------------------------------------------------------------------------------
## -- History :
## -- yyyy-mm-dd  Ver.      Auth.    Description
## -- 2025-09-19  1.0.0     DA       Creation 
## -------------------------------------------------------------------------------------------------

"""
Ver. 1.0.0 (2025-09-19)

This module provides an elementary stream generator shaping a single cluster of random points with any

- number of dimensions,
- number of instances,
- start and end center,
- start and end radii,
- random seed,
- data type (float32, float64)

"""

from typing import Union, Literal, List
import numpy as np
import random

from mlpro.bf import Log, Mode
from mlpro.bf.exceptions import ParamError
from mlpro.bf.math import Element, MSpace, ESpace
from mlpro.bf.streams import Feature, Instance, Stream



# Export list for public API
__all__ = [ 'StreamCluster' ]



## -------------------------------------------------------------------------------------------------
## -------------------------------------------------------------------------------------------------
class StreamCluster(Stream):
    """
    Elementary stream generator shaping a single cluster of random points in the d-dimensional 
    feature space [-1000,1000]^d. The cluster can be static or dynamic (moving and/or changing its size) 
    over the total number of instances.

    Parameters
    ----------
    p_num_dim : int
        Number of dimensions of the cluster.
    p_num_instances : int
        Total number of instances to be generated by the stream.
    p_center_start : 'rnd' or list of float, default='rnd'
        Starting center of the cluster. If 'rnd', a random center within the boundaries will be
        generated.
    p_center_end : None, 'rnd' or list of float, default=None
        Optional end center of the cluster. If 'rnd', a random center within the boundaries will be
        generated. If provided, the cluster will move linearly from the start center to the end
        center over the total number of instances. If None, the cluster will remain static.
    p_radii_start : 'rnd' or list of float, default='rnd'
        Starting radii of the cluster. If 'rnd', random radii will be generated within 10% of the
        boundary range.
    p_radii_end : None, 'rnd' or list of float, default=None
        Optional end radii of the cluster. If 'rnd', random radii will be generated within 10% of the
        boundary range. If provided, the radii will change linearly from the start radii to the end
        radii over the total number of instances. If None, the radii will remain static.
    p_enable_instance_exceeding : bool, default=False
        If True, the stream will continue to generate instances even if the number of generated
        instances exceeds p_num_instances. If False, the stream will stop generating instances
        once p_num_instances is reached.
    p_seed : int, default=1
        Random seed for reproducibility.
    p_dtype : type, default=np.float32
        Data type for the cluster parameters.
    p_logging : int, default=Log.C_LOG_NOTHING
        Logging level.

    Attributes
    ----------
    center : np.array
        Current center of the cluster.
    radii : np.array
        Current radii of the cluster.
    velocities : np.array
        Current velocities of the cluster.
    """

    C_NAME              = 'Cluster'
    C_RADII_RND_FACTOR  = 0.2          # Factor for random radii generation within boundary range
    C_BOUNDARIES        = [-1000, 1000] # Boundaries of the feature space
  
## -------------------------------------------------------------------------------------------------
    def __init__( self,
                  p_num_dim : int,
                  p_num_instances : int,
                  p_center_start : Union[Literal['rnd'], List[float]] = 'rnd',
                  p_center_end : Union[None, Literal['rnd'], List[float]] = None,
                  p_radii_start : Union[Literal['rnd'], List[float]] = 'rnd',
                  p_radii_end : Union[None, Literal['rnd'], List[float]] = None,
                  p_enable_instance_exceeding : bool = False,
                  p_seed : int = 1,
                  p_dtype : type = np.float32,
                  p_logging : int = Log.C_LOG_NOTHING ):
        
        # 0 Parameter checks
        if p_num_dim < 1:
            raise ParamError('p_num_dim must be greater than 0!')       
        
        if p_num_instances < 1:
            raise ParamError('p_num_instances must be greater than 0!')
        
        if p_center_start not in ['rnd'] and not isinstance(p_center_start, list):
            raise ParamError('p_center_start must be either "rnd" or a list of floats!')
        elif isinstance(p_center_start, list) and len(p_center_start) != p_num_dim:
            raise ParamError('Length of p_center_start must be equal to p_num_dim!')

        if p_center_end not in [None, 'rnd'] and not isinstance(p_center_end, list):
            raise ParamError('p_center_end must be either None, "rnd" or a list of floats!')
        elif isinstance(p_center_end, list) and len(p_center_end) != p_num_dim:
            raise ParamError('Length of p_center_end must be equal to p_num_dim!')

        if p_radii_start not in ['rnd'] and not isinstance(p_radii_start, list):
            raise ParamError('p_radii_start must be either "rnd" or a list of floats!')
        elif isinstance(p_radii_start, list) and len(p_radii_start) != p_num_dim:
            raise ParamError('Length of p_radii_start must be equal to p_num_dim!')

        if p_radii_end not in [None, 'rnd'] and not isinstance(p_radii_end, list):
            raise ParamError('p_radii_end must be either None, "rnd" or a list of floats!') 
        elif isinstance(p_radii_end, list) and len(p_radii_end) != p_num_dim:
            raise ParamError('Length of p_radii_end must be equal to p_num_dim!')
        
        if p_dtype not in [np.float32, np.float64]:
            raise ParamError('p_dtype must be either np.float32 or np.float64!')    
        
        if ( p_center_end is None and p_radii_end is not None ) or ( p_center_end is not None and p_radii_end is None ):
            raise ParamError('p_center_end and p_radii_end must be both provided or both None!')
        
        if p_center_end is not None and p_num_instances == 1:
            raise ParamError('p_num_instances must be greater than 1 if p_center_end is supplied!')
        
        
        # 1 Init all attributes

        # 1.1 Numerics
        self._dtype : type      = p_dtype
        self.set_random_seed(p_seed)

        # 1.2 Cluster generation
        self._num_dim : int     = p_num_dim
        self._enable_instance_exceeding : bool = p_enable_instance_exceeding
        self._num_instances_ref : int = p_num_instances
        if p_enable_instance_exceeding: self._num_instances = 0

        # 1.3 Cluster attributes
        self._center_start = p_center_start
        self._center_end   = p_center_end
        self._radii_start  = p_radii_start
        self._radii_end    = p_radii_end
        self.size : int    = 0


        # 2 Call parent initializations
        super().__init__( #p_id = 0,
                          #p_name = p_name,
                          p_num_instances = self._num_instances,
                          #p_version = p_version,
                          p_feature_space = self._setup_feature_space(),
                          #p_label_space = p_label_space,
                          #p_sampler = p_sampler,
                          p_mode = Mode.C_MODE_SIM,
                          p_logging = p_logging )


## -------------------------------------------------------------------------------------------------
    def _setup_feature_space(self) -> MSpace:
        feature_space : MSpace = ESpace()

        for i in range(self._num_dim):
            feature_space.add_dim( Feature( p_name_short = 'f_' + str(i),
                                            p_base_set = Feature.C_BASE_SET_R,
                                            p_name_long = 'Feature #' + str(i),
                                            p_name_latex = '',
                                            p_description = '',
                                            p_symmetrical = False,
                                            p_logging=Log.C_LOG_NOTHING ) )
        return feature_space    
    

## -------------------------------------------------------------------------------------------------
    def _gen_rnd_array(self, p_low, p_high, p_size) -> np.array:
        return np.array( [ random.uniform(p_low, p_high) for _ in range(p_size) ], dtype=self._dtype )
    

## -------------------------------------------------------------------------------------------------
    def _reset(self):

       # 1.1 Center, start
        if self._center_start == 'rnd':
            self.center = self._gen_rnd_array(self.C_BOUNDARIES[0], self.C_BOUNDARIES[1], self._num_dim)
        else:
            self.center = np.array(self._center_start, dtype=self._dtype)


        # 1.2 Center, end and velocities
        if self._center_end != None:

            if self._center_end != 'rnd':
                self._center_end = np.array(self._center_end, dtype=self._dtype)
            else:
                self._center_end = self._gen_rnd_array(self.C_BOUNDARIES[0], self.C_BOUNDARIES[1], self._num_dim)

            self.velocities = (self._center_end - self.center) / ( self._num_instances_ref - 1 )

        else:
            self.velocities  = np.zeros(self._num_dim, dtype=self._dtype)


        # 1.3 Radii, start
        if self._radii_start == 'rnd':

            self.radii = self._gen_rnd_array(0, (self.C_BOUNDARIES[1] - self.C_BOUNDARIES[0]) * self.C_RADII_RND_FACTOR, self._num_dim)

        else:
            self.radii = np.array(self._radii_start, dtype=self._dtype)


        # 1.4 Radii, end and rate of change of radii
        if self._radii_end != None:

            if self._center_end is None:
                raise ParamError('p_center_end must be provided if p_radii_end is provided!')

            if self._radii_end != 'rnd':

                if len(self._radii_end) != self._num_dim:
                    raise ParamError('Length of p_radii_end must be equal to p_num_dim!')

                self._radii_end = np.array(self._radii_end, dtype=self._dtype)

            else:
                self._radii_end = self._gen_rnd_array( 0, 
                                                       (self.C_BOUNDARIES[1] - self.C_BOUNDARIES[0]) * self.C_RADII_RND_FACTOR, 
                                                       self._num_dim )

            self._roc_of_radii = (self._radii_end - self.radii) / self._num_instances_ref

        else:
            self._roc_of_radii = np.zeros(self._num_dim, dtype=self._dtype)
 

## -------------------------------------------------------------------------------------------------
    def _get_next(self) -> Instance:

        # 1 Prepare a new instance
        feature_data = Element( p_set = self.get_feature_space() )
        new_inst     = Instance( p_feature_data = feature_data, p_tstamp = self.tstamp )
        

        # 2 Generate a random point within the cluster
        v  = np.random.normal(size=self._num_dim)
        v /= np.linalg.norm(v)
        r  = np.random.rand() ** (1.0 / self._num_dim)

        feature_data.set_values( self.center + v * r * self.radii )


        # 3 Update cluster parameters
        np.add( self.center, self.velocities, out=self.center )
        np.add( self.radii, self._roc_of_radii, out=self.radii )
        self.size += 1


        # 4 Return new instance
        return new_inst